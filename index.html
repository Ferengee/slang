<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script type="text/javascript" src="javascripts/lang.js"></script>
    <title>Slang by Ferengee</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Slang</h1>
        <h2>A small language inspired on scheme and  &#39;Structure and Interpretation of Computer Programs&#39;<a href="https://mitpress.mit.edu/sicp/full-text/book/book.html">(https://mitpress.mit.edu/sicp/full-text/book/book.html)</a></h2>

        <section id="downloads">
          <a href="https://github.com/Ferengee/slang/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/Ferengee/slang/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/Ferengee/slang" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a id="slang-interactive-demo" class="anchor" href="#slang-interactive-demo" aria-hidden="true"><span class="octicon octicon-link"></span></a>a Slang interactive demo</h3>
<a class="btn clearbtn" onclick="clearOutput()">clear</a>

<ul id="output">
  <li>Define variables with (define name value)</li>
  <li>Define functions with (define (function-name param1 param2)(body)) </li>
  <li>The wizard game from Land of lisp <a href="http://lisperati.com/data.html">(http://lisperati.com/data.html)</a>
      is loaded into this demo. Use (look) to start.
  </li>

  <li>(globals) gives you the list of global variables</li>
  <li>use () to apply a function, for example (+ 2 3) which applies +</li>
  <li>Functions can be partially applied, which will result in a new function</li>
  <li>run just the function name to see the implementation, or click edit to alter it</li>
  <li>Function parameters can be applied with keyword symbols, for example </li>
  <ol>
    <li>(define (test a b) (- a b))</li>
    <li>(test :b 7 :a 3)</li>

  </ol>


  
</ul>
<div class="control">
  <select id="suggest"></select><a class="btn" id="suggest-ok" onclick="enterSuggestion()">ok</a>
</div>
<div class="control">
 
  <textarea rows="16" type="text" id="cmdline" inputmode="latin lowerCase" onKeyDown="handleKeyDown(event)" onKeyUp="handleKeyUp(event)" ></textarea>
  <ol class="edit-btns"> 
    <li><a class="btn" onclick="balance()">balance</a></li>
    <li><a class="btn" onclick="enter()">run ‚èé</a></li>
  
   

    <li><a class="btn" onclick="fromEnv()">edit</a></li>
    <li><a class="btn disabled" onclick="save()">save</a></li>
    <li><a class="btn disabled" onclick="load()">load</a></li>
  </ol>
</div>


<div style="display: none;">
  <a onclick="add('(')">(</a>
  <a onclick="add(')')">)</a>
  <a onclick="add('define')">define</a>
  <a onclick="add('lambda')">lambda</a>
  <a onclick="add('cond')">cond</a>
  <a onclick="add('list')">list</a>
  <a onclick="add('cons')">cons</a>
  <a onclick="add('car')">car</a>
  <a onclick="add('cdr')">cdr</a>
</div>

<script type="text/slang" id="prelude" language="slang">
; <!-- 

(define ! 
  (lambda (n)
    (cond
      ((< n 2) n) 
      (t (* n (! (- n 1)))))))

(define !i
  (lambda (x)
    (define iter 
      (lambda (n m) 
        (cond
          ((= n 0) m)
          (t (iter (- n 1) (* m n)))
        )
      ))
      (iter x 1)))

(define map* (lambda (fn . lists)
  (cond 
    ((nil? lists) '())
    ((has-nil (map car lists)) '())
    (t (cons  (apply fn (map car lists)) (apply map* (cons fn (map cdr lists) ))))
  )
))

(define has-nil (lambda (list) 
  (cond
    ((nil? list) nil)
    ((nil? (car list)) t)
    (t (has-nil (cdr list)))
   ) 
))

(define ^ (lambda (x n) (cond (( < n 1) 1) (t (* x (^ x (- n 1 ))))) ))
(define last (lambda (x)( cond (( nil? (cdr x)) (car x))( t (last (cdr x))))))
(define concat (lambda (x)( cond ((nil? x) nil) ((nil? (car x)) (concat (cdr x)))( t (cons (car (car x)) (concat (cons(cdr(car x)) (cdr x))))))))
(define append (lambda x (concat x)))
(define mapcar (lambda (fn l) (cond ((eq? l '()) '()) (else (cons (fn (car l)) (mapcar fn (cdr l)) )) ))) 
(define test (lambda (x . y)  y )) 
(define list (lambda x x))
(define map (lambda (fn l) (cond ((eq? l '()) '()) (else (cons (fn (car l)) (map fn (cdr l)) )) ))) 
(define !i (lambda (x)(define iter (lambda (n m) (cond((= n 0) m)(t (iter (- n 1) (* m n))))))(iter x 1)))
(define y (lambda (f) ((lambda (x)(f (lambda (y) ((x x) y) ))) (lambda (x) (f (lambda (y) ((x x)  y) ) )))))
(define fact-gen (lambda (fact) (lambda (n) (cond ((= n 0) 1)( t (* n (fact (- n 1))))))))
(define (assoc key lst) (cond ((nil? lst) nil) ((eq? (car (car lst)) key) (car lst)) (t (assoc key (cdr lst)))))
(define (add-pair key val lst)(cons (cons key val) lst))
(define (zip keys values . fn) (define (do keys values fn) (cond ((and keys values) (cons (fn (car keys) (car values)) (do (cdr keys) (cdr values) fn))))) (do keys values (cond ((nil? fn) (cons)) (t (car fn)))))
(define reduce (lambda (fn lst :acc nil) (cond ((nil? lst) acc) (t (reduce fn (cdr lst) (fn (car lst) acc))))))
(define (compare fn a b) (cond   ((fn a b) a)   (t b) ))
(define (testIf fn a b) (cond   ((fn a) a)   (t b) ))
(define (minimum lst) (reduce (compare <) lst (car lst)))
(define (maximum lst) (reduce (compare >) lst (car lst)))
(define (not a)  (cond   ((nil? a) t)))
(define (not-fn fn a) (not (fn a)))
(define (apply-on args proc ) (apply proc args))
(define (range from to . step) 
    (define 
      (do from to step acc) 
      (cond 
        ((>= to from) 
          (do (+ from step) to step (cons from acc))) 
        (t acc)
      )
    )
    (reverse (do from to 
      (testif 
        (not-fn nil?) 
        (car step) 1) nil)))
(define reverse (reduce cons))
; / --> 

</script>


<script type="text/slang" id="wizard-game" language="slang">
; <!-- 
;scheme compatibilty:
;
; (define nil ())
; (define (nil? x) (eq? x nil))
; (define t #t)
; (define mapcar map)


(define *nodes* '((living-room (you are in the living-room.
                            a wizard is snoring loudly on the couch.))
                        (garden (you are in a beautiful garden.
                            there is a well in front of you.))
                        (attic (you are in the attic.
                            there is a giant welding torch in the corner.))))

(define (describe-location location nodes)
   (cadr (assoc location nodes)))

(define *edges* '((living-room (garden west door)
                                     (attic upstairs ladder))
                        (garden (living-room east door))
                        (attic (living-room downstairs ladder))))


(define (describe-path edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))

(define (describe-paths location edges)
  (apply append (map describe-path (cdr (assoc location edges)))))

(define *object-locations* '((whiskey living-room)
                                   (bucket living-room)
                                   (chain garden)
                                   (frog garden)))
(define (remove-if-not fn lst)
  (cond
    ((nil? lst) nil)
    ((fn (car lst)) (cons (car lst) (remove-if-not fn (cdr lst))))
    (t  (remove-if-not fn (cdr lst)))
  )
)

(define (objects-at loc objs obj-locs)
  (define (at-loc-p obj)
    (eq? (cadr (assoc obj obj-locs)) loc))
  (remove-if-not at-loc-p objs))

(define *objects* '(whiskey bucket frog chain))

(define (describe-objects loc objs obj-loc)
  (define (describe-obj obj)
               `(you see a ,obj on the floor.))
    (apply append (map describe-obj (objects-at loc objs obj-loc))))

(define (look)
  (append (describe-location *location* *nodes*)
          (describe-paths *location* *edges*)
          (describe-objects *location* *objects* *object-locations*)))

(define *location* 'living-room)


;(defun walk (direction)
;  (let ((next (find direction
;                    (cdr (assoc *location* *edges*))
;                    :key #'cadr)))
;  (if next
;      (progn (setf *location* (car next))
;             (look))
;      '(you cannot go that way.))))

(define (walk direction)
  (define (do next)
    (define (go)
      (set! *location* (car next))
      (look)
    )
    (cond
      ((nil? next) '(you cannot go that way))
      (t (go))))
  (do (find direction (cdr (assoc *location* *edges*)) cadr))
)

(define (generate-finder matchfn needle lst)
  (cond
    ((nil? lst) nil)
    ((eq? (matchfn (car lst)) needle) (car lst))
    (t (generate-finder matchfn needle (cdr lst)))
  )
)

(define (find needle lst . matchfn)
  (generate-finder (cond ((nil? matchfn) car) (t (car matchfn))) needle lst)
)

(define (closure-test x)
  (lambda () x)
)

(define (pickup object)
  (cond 
    ((member object
         (objects-at *location* *objects* *object-locations*))
     (push! (list object 'body) *object-locations*)
           `(you are now carrying the ,object))
    (t '(you cannot get that.))))

;(walk 'west)
(define (identity x) x)
(define member (generate-finder identity))

(define (inventory)
  (cons 'items- (objects-at 'body *objects* *object-locations*)))

(define help '(use (look) to look around and use (walk) to move around. Use (inventory) to see what you are carrying))


(define (have object)
    (member object (inventory)))

(define *chain-welded* nil)

(define *bucket-filled* nil)

(define (create-game-action name actionfn location expected-subject expected-object precondition subject object)
  (cond ((and (eq? *location* location)
            (eq? subject expected-subject)
            (eq? object expected-object)
            (have expected-subject)
            (precondition))
            (actionfn)
         )
    (t `(you cannot ,name like that.))))

(define dunk 
  (create-game-action 'dunk (lambda () 
    (set! *bucket-filled* t) 
    '(the bucket is now full of water.)
    ) 'garden 'bucket 'well (lambda () *chain-welded*)))

(define weld 
  (create-game-action 'weld (lambda () 
    (set! *chain-welded* t) 
    '(the chain is now securely welded to the bucket.)
    ) 'attic 'chain 'bucket (lambda () (not *chain-welded*))))

(define splash (create-game-action 'splash (lambda ()
   (cond ((not *bucket-filled*) '(the bucket has nothing in it.))
         ((have 'frog) '(the wizard awakens and sees that you stole his frog.
                         he is so upset he banishes you to the
                         netherworlds- you lose! the end.))
         (t '(the wizard awakens from his slumber and greets you warmly.
              he hands you the magic low-carb donut- you win! the end.)))
    ) 'living-room 'bucket 'wizard (lambda ()t)))

; / --> 
</script>

 <script language="javascript" defer>

  
    function loadSlangCode(id){
      var inputbuffer = "";
      var lines = document.getElementById(id).text.split('\n');
      for(var i=0; i< lines.length; i++){
        var line = lines[i];
        if(line.indexOf(";") != 0){
          try{
            var input = inputbuffer + '\n' +line; 
            console.log("=>","" + eval(read(input), env));
            inputbuffer = "";  
          } catch(e){
            if(e.retry){
              inputbuffer = input;
            } else {
              console.log(e);
            }
          }
        }    
      }
    }
    
/*
 * TODO: match whole env  and not just the top frame
 */
    function matchKeysFromEnv(part){
      var list = env;
      var result = [];
      while(!isNil(list)) {
        result = result.concat(matchKeysFromFrame(part, car(list)));
        list = cdr(list);
      }
      //var result = matchKeysFromFrame(part, topFrame);
      return result;
    }

    function matchKeysFromFrame(part, frame){
      part = part.toLowerCase();
      var pair = frame;
      var result = [];
      for(name in frame){
        if(name.indexOf(part) > -1){
          result.push(name);
        }
      }
      return result;
    }

    function insertText(token, caret, replaceCount){
      replaceCount = replaceCount || 0;
      var cmdline = document.getElementById("cmdline");
      var value = cmdline.value;

      cmdline.value = value.substr(0, caret - replaceCount) + token + value.substr(caret);
      cmdline.focus();
      caret = caret + token.length;
      cmdline.setSelectionRange(caret, caret);
      cmdline.scrollIntoView();    
    }

    function handleKeyDown(e){
      if(e.keyCode == 9){
        e.preventDefault();
        enterSuggestion();
        cmdline.focus();
        return false;
      }
    }
    
    function enterSuggestion(){
      var cmdline = document.getElementById("cmdline");
      var caret = cmdline.selectionStart;
      var suggest = document.getElementById('suggest');
      insertText(suggest.value, caret, getPart(cmdline).length);
    }

    function getPart(cmdline){
      var caret = cmdline.selectionStart;
      return cmdline.value.substr(0, caret).split(/[ \)\(]/).slice(-1)[0];
    }

    function handleKeyUp(e){
      var cmdline = document.getElementById("cmdline");

      if (typeof e == 'undefined' && window.event) { 
        e = window.event; 
      }
      if (e.keyCode == 13 && e.shiftKey)
      {
        e.preventDefault();
        balance();
        enter();
        cmdline.value ="";
        return false;
      }
      
      var value = cmdline.value;
      var caret = cmdline.selectionStart;
      var part = getPart(cmdline);
      var choice = []; 
      var matches =  matchKeysFromEnv(part);
      for(var x = 0; x < matches.length; x++){
        choice.push("<option value='" + matches[x] + "'>"+matches[x]+"</option>");
      }
      var suggest = document.getElementById('suggest');
      suggest.innerHTML = choice.join("");
      suggest.onchange = function(){
         clickCount++;
         insertText(this.value, caret, part.length);
      }
      var clickCount  = 0;
      suggest.onclick = function(){

        if(clickCount == 1){
          insertText(this.value, caret, part.length);
        }
        clickCount++;
      }
    }

    function appendResult(result){
      var item = document.createElement('li');
      item.innerHTML = "<p>" + indent(result.toString(), "<br />", "&nbsp") + "</p>";
      document.getElementById("output").appendChild(item);
    }
  
    function keydown(event){
      if(event.keyCode == 13){
        enter();
      }
    }

    function listStorage(){
      var result = nil;
      for(var i =0; i < localStorage.length; i++){
        result = cons(intern(localStorage.key(i)), result);
      }
      return result;
    }

    function saveStorage(symbol){
      value = eval(symbol, env);
      localStorage.setItem(symbol.name, value.toString());
      return value;
    }

    function loadStorage(symbol){
      var code = localStorage.getItem(symbol.name);
      eval(read(["(define",symbol.name,code,")"].join(" ")),env);
      return symbol;
    }
    
    registerKeyword("globals",function(){return arrayToConsList(Object.keys(car(env)));},[]);
    registerKeyword("storage->list",listStorage);
    registerKeyword("storage->save",saveStorage, ['variable']);  
    registerKeyword("storage->load",loadStorage, ['variable']);  

    registerKeyword("storage->clear",function(){localStorage.clear(); return nil;});

    clear = clearOutput = function (){
      document.getElementById("output").innerHTML = "";
      return "";
    }
    function enter(){
      var result;
      try{
        result = eval(read(document.getElementById("cmdline").value.toString()), env);
      } catch(e){
        result = e;
      }
      appendResult(result);
    }

    function indent(code, newline, space){
      if(newline === undefined) 
        newline = '\n';

      if (space === undefined) 
        space = ' ';

      var depth = 0;

      var result = "";
      for(var i =0 ; i < code.length; i++){
        if(code[i] == "(" ){
          if( code[i - 1] && code[i - 1] != "("){
            result = result + newline;
            
            for(var j = 0; j < depth; j ++){
              result = result + space + space;
            }
          }
          depth = depth + 1;
        } else if (code[i] == ")"){
          depth = depth - 1;
        }
        result = result + code[i];
      }
      return result;
    }

    function fromEnv(){
      var cmdline = document.getElementById("cmdline");
      var result = "";
      var variable = cmdline.value.toString();
       
      try{
        var code = ["(define ", variable, eval(read(variable), env).toString(), ")"].join("") ;
        
        result = indent(code);
        cmdline.value = result; 
      } catch(e){
        appendResult(e);
      }
    }

    function add(token){
      var cmdline = document.getElementById("cmdline");
      var caret = cmdline.selectionStart;


      insertText(token, caret);
    }

    function balance(){
      var cmdline = document.getElementById("cmdline");

      var open = cmdline.value.split("(").length -1;
      var closed = cmdline.value.split(")").length -1;

      var r = "";
      while(open > closed){
       r = r + ")";
       closed = closed +1;
      }
      cmdline.value = cmdline.value + r;
    }

    loadSlangCode('prelude');
    loadSlangCode('wizard-game');


  </script>
      </section>
    </div>

    
  </body>
</html>