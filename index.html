<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script type="text/javascript" src="https://raw.githubusercontent.com/Ferengee/slang/master/lang.js"></script>
    <title>Slang by Ferengee</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Slang</h1>
        <h2>A small language inspired on scheme and  &#39;Structure and Interpretation of Computer Programs&#39;<a href="https://mitpress.mit.edu/sicp/full-text/book/book.html">(https://mitpress.mit.edu/sicp/full-text/book/book.html)</a></h2>

        <section id="downloads">
          <a href="https://github.com/Ferengee/slang/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/Ferengee/slang/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/Ferengee/slang" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to GitHub Pages.</h3>
<div class="control" style="position: fixed; padding:0px; margin-top:0px; top:0px;">
  <select id="suggest"></select>
  <button onclick="enterSuggestion()">ok</button>

  <button onclick="balance()">balance</button>
  <button onclick="enter()">run</button>
</div>
<ul id="output"></ul>


<div class="control">
  <textarea rows="6" type="text" id="cmdline" inputmode="latin lowerCase" onKeyUp="suggest()" ></textarea>
  <button onclick="clearOutput()">clear</button>
  <button onclick="fromEnv()">edit</button>
  <button onclick="save()">save</button>
  <button onclick="load()">load</button>
</div>


<div style="display: none;">
  <button onclick="add('(')">(</button>
  <button onclick="add(')')">)</button>
  <button onclick="add('define')">define</button>
  <button onclick="add('lambda')">lambda</button>
  <button onclick="add('cond')">cond</button>
  <button onclick="add('list')">list</button>
  <button onclick="add('cons')">cons</button>
  <button onclick="add('car')">car</button>
  <button onclick="add('cdr')">cdr</button>
</div>

<script type="text/slang" id="wizard-game" language="slang">
; <!-- 
;scheme compatibilty:
;
; (define nil ())
; (define (nil? x) (eq? x nil))
; (define t #t)
; (define mapcar map)


(define *nodes* '((living-room (you are in the living-room.
                            a wizard is snoring loudly on the couch.))
                        (garden (you are in a beautiful garden.
                            there is a well in front of you.))
                        (attic (you are in the attic.
                            there is a giant welding torch in the corner.))))

(define (describe-location location nodes)
   (cadr (assoc location nodes)))

(define *edges* '((living-room (garden west door)
                                     (attic upstairs ladder))
                        (garden (living-room east door))
                        (attic (living-room downstairs ladder))))


(define (describe-path edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))

(define (describe-paths location edges)
  (apply append (map describe-path (cdr (assoc location edges)))))

(define *object-locations* '((whiskey living-room)
                                   (bucket living-room)
                                   (chain garden)
                                   (frog garden)))
(define (remove-if-not fn lst)
  (cond
    ((nil? lst) nil)
    ((fn (car lst)) (cons (car lst) (remove-if-not fn (cdr lst))))
    (t  (remove-if-not fn (cdr lst)))
)
)

(define (objects-at loc objs obj-locs)
  (define (at-loc-p obj)
    (eq? (cadr (assoc obj obj-locs)) loc))
  (remove-if-not at-loc-p objs))

(define *objects* '(whiskey bucket frog chain))

(define (describe-objects loc objs obj-loc)
  (define (describe-obj obj)
               `(you see a ,obj on the floor.))
    (apply append (map describe-obj (objects-at loc objs obj-loc))))

(define (look)
  (append (describe-location *location* *nodes*)
          (describe-paths *location* *edges*)
          (describe-objects *location* *objects* *object-locations*)))

(define *location* 'living-room)


;(defun walk (direction)
;  (let ((next (find direction
;                    (cdr (assoc *location* *edges*))
;                    :key #'cadr)))
;  (if next
;      (progn (setf *location* (car next))
;             (look))
;      '(you cannot go that way.))))

(define (walk direction)
  (define (do next)
    (define (go)
      (set! *location* (car next))
      (look)
    )
    (cond
      ((nil? next) '(you cannot go that way))
      (t (go))))
  (do (find direction (cdr (assoc *location* *edges*)) cadr))
)

(define (generate-finder matchfn needle lst)
  (cond
    ((nil? lst) nil)
    ((eq? (matchfn (car lst)) needle) (car lst))
    (t (generate-finder matchfn needle (cdr lst)))
  )
)

(define (find needle lst . matchfn)
  (generate-finder (cond ((nil? matchfn) car) (t (car matchfn))) needle lst)
)

(define (closure-test x)
  (lambda () x)
)

(define (pickup object)
  (cond 
    ((member object
         (objects-at *location* *objects* *object-locations*))
     (push! (list object 'body) *object-locations*)
           `(you are now carrying the ,object))
    (t '(you cannot get that.))))

;(walk 'west)
(define (identity x) x)
(define member (generate-finder identity))

(define (inventory)
  (cons 'items- (objects-at 'body *objects* *object-locations*)))

(define help '(use (look) to look around and use (walk) to move around. Use (inventory) to see what you are carrying))


(define (have object)
    (member object (inventory)))

(define *chain-welded* nil)

(define *bucket-filled* nil)

(define (create-game-action name actionfn location expected-subject expected-object precondition subject object)
  (cond ((and (eq? *location* location)
            (eq? subject expected-subject)
            (eq? object expected-object)
            (have expected-subject)
            (precondition))
            (actionfn)
         )
    (t `(you cannot ,name like that.))))

(define dunk 
  (create-game-action 'dunk (lambda () 
    (set! *bucket-filled* t) 
    '(the bucket is now full of water.)
    ) 'garden 'bucket 'well (lambda () *chain-welded*)))

(define weld 
  (create-game-action 'weld (lambda () 
    (set! *chain-welded* t) 
    '(the chain is now securely welded to the bucket.)
    ) 'attic 'chain 'bucket (lambda () (not *chain-welded*))))

(define splash (create-game-action 'splash (lambda ()
   (cond ((not *bucket-filled*) '(the bucket has nothing in it.))
         ((have 'frog) '(the wizard awakens and sees that you stole his frog.
                         he is so upset he banishes you to the
                         netherworlds- you lose! the end.))
         (t '(the wizard awakens from his slumber and greets you warmly.
              he hands you the magic low-carb donut- you win! the end.)))
    ) 'living-room 'bucket 'wizard (lambda ()t)))

; / --> 
</script>

 <script language="javascript" defer>

    var extensions = [
      "(define ! " +
      "  (lambda (n)" + 
      "    (cond" + 
      "      ((< n 2) n) " +
      "      (t (* n (! (- n 1)))))))",
      "(define !i" +
      "  (lambda (x)" +
      "    (define iter " +
      "      (lambda (n m) " +
      "        (cond" +
      "          ((eq? n 0) m)" +
      "          (t (iter (- n 1) (* m n)))" +
      "        )" +
      "      ))" +
      "      (iter x 1)))",
      "(define map* (lambda (fn . lists)" +
      "  (cond " +
      "    ((nil? lists) '())" +
      "    ((has-nil (map car lists)) '())" +
      "    (t (cons  (apply fn (map car lists)) (apply map* (cons fn (map cdr lists) ))))" +
      "  )" +
      "))",
      "(define has-nil (lambda (list) " +
      "  (cond" +
      "    ((nil? list) nil)" +
      "    ((nil? (car list)) t)" +
      "    (t (has-nil (cdr list)))" +
      "   ) " +
      "))",
      "(define ^ (lambda (x n) (cond (( < n 1) 1) (t (* x (^ x (- n 1 ))))) ))",
      "(define last (lambda (x)( cond (( nil? (cdr x)) (car x))( t (last (cdr x))))))",
      "(define concat (lambda (x)( cond ((nil? x) nil) ((nil? (car x)) (concat (cdr x)))( t (cons (car (car x)) (concat (cons(cdr(car x)) (cdr x))))))))",
      "(define append (lambda x (concat x)))",
      "(define mapcar (lambda (fn l) (cond ((eq? l '()) '()) (else (cons (fn (car l)) (mapcar fn (cdr l)) )) ))) ",
      "(define test (lambda (x . y)  y )) ",
      "(define list (lambda x x))",
      "(define map (lambda (fn l) (cond ((eq? l '()) '()) (else (cons (fn (car l)) (map fn (cdr l)) )) ))) ",
      "(define !i (lambda (x)(define iter (lambda (n m) (cond((eq? n 0) m)(t (iter (- n 1) (* m n))))))(iter x 1)))",
      "(define y (lambda (f) ((lambda (x)(f (lambda (y) ((x x) y) ))) (lambda (x) (f (lambda (y) ((x x)  y) ) )))))",
      "(define fact-gen (lambda (fact) (lambda (n) (cond ((eq? n 0) 1)( t (* n (fact (- n 1))))))))",
      "(define (assoc key lst) (cond ((nil? lst) nil) ((eq? (car (car lst)) key) (car lst)) (t (assoc key (cdr lst)))))",
      "(define (add-pair key val lst)(cons (cons key val) lst))",
      "(define (zip keys values . fn) (define (do keys values fn) (cond ((and keys values) (cons (fn (car keys) (car values)) (do (cdr keys) (cdr values) fn))))) (do keys values (cond ((nil? fn) (cons)) (t (car fn)))))",
      "(define reduce (lambda (fn lst . acc) (cond ((nil? lst) (car acc)) (t (reduce fn (cdr lst) (fn (car lst) (car acc)))))))",
      "(define (compare fn a b) (cond   ((fn a b) a)   (t b) ))",
      "(define (testIf fn a b) (cond   ((fn a) a)   (t b) ))",
      "(define (minimum lst) (reduce (compare <) lst (car lst)))",
      "(define (maximum lst) (reduce (compare >) lst (car lst)))",
      "(define (not a)  (cond   ((nil? a) t)))",
      "(define (not-fn fn a) (not (fn a)))",
      "(define (apply-on args proc ) (apply proc args))",
      "(define (range from to . step)  (define (do from to step) (cond ((>= to from) (cons from (do (+ from step) to step)))   ) ) (do from to (testIf (not-fn nil?) (car step) 1)))",
      "(define (globals) (map car (cdr (car (printenv)))))",
      "(define reverse (reduce cons))"
    ];
    
    for(var i = 0; i < extensions.length ; i++){
      eval(read(extensions[i]), env);
    }

    function loadWizardGame(){
      var inputbuffer = "";
      var lines = document.getElementById('wizard-game').text.split('\n');
      for(var i=0; i< lines.length; i++){
        var line = lines[i];
        if(line.indexOf(";") != 0){
          try{
            var input = inputbuffer + '\n' +line; 
            console.log("=>","" + eval(read(input), env));
            inputbuffer = "";  
          } catch(e){
            if(e.retry){
              inputbuffer = input;
            } else {
              console.log(e);
            }
          }
        }    
      }
    }
    
/*
 * TODO: match whole env  and not just the top frame
 */
    function matchKeysFromEnv(part){
      var list = env;
      var result = [];
      while(!isNil(list)) {
        result = result.concat(matchKeysFromFrame(part, car(list)));
        list = cdr(list);
      }
      //var result = matchKeysFromFrame(part, topFrame);
      return result;
    }

    function matchKeysFromFrame(part, frame){
      part = part.toLowerCase();
      var pair = frame;
      var result = [];
      while(!isNil(pair)){
        var item = car(pair);
        var name = car(item).name;
        if(name === undefined){
          console.log(item);
        }else if(!isNil(item) &&  name.indexOf(part) > -1){
          result.push(name);
        }
        pair = cdr(pair)
      }
      return result;
    }

    function insertText(token, caret, replaceCount){
          console.log("token: ",token);

          console.log("position: ", caret);
          console.log("replaceCount: ",replaceCount);


      replaceCount = replaceCount || 0;
      var cmdline = document.getElementById("cmdline");
      var value = cmdline.value;

      cmdline.value = value.substr(0, caret - replaceCount) + token + value.substr(caret);
      cmdline.focus();
      caret = caret + token.length;
      cmdline.setSelectionRange(caret, caret);
      cmdline.scrollIntoView();    
    }
    
    function enterSuggestion(){
      var cmdline = document.getElementById("cmdline");
      var caret = cmdline.selectionStart;
      var suggest = document.getElementById('suggest');
      insertText(suggest.value, caret, getPart(cmdline).length);
    }

    function getPart(cmdline){
      var caret = cmdline.selectionStart;
      return cmdline.value.substr(0, caret).split(/[ \)\(]/).slice(-1)[0];
    }

    function suggest(){
      var cmdline = document.getElementById("cmdline");
      var value = cmdline.value;
      var caret = cmdline.selectionStart;
      var part = getPart(cmdline);
      var choice = []; 
      var matches =  matchKeysFromEnv(part);
      for(var x = 0; x < matches.length; x++){
        choice.push("<option value='" + matches[x] + "'>"+matches[x]+"</option>");
      }
      var suggest = document.getElementById('suggest');
      suggest.innerHTML = choice.join("");
      suggest.onchange = function(){
         clickCount++;
         insertText(this.value, caret, part.length);
      }
      var clickCount  = 0;
      suggest.onclick = function(){

        if(clickCount == 1){
          console.log("replacing:", part," with ", this.value);
          insertText(this.value, caret, part.length);
        }
        clickCount++;

      }


    }
    function appendResult(result){
      var item = document.createElement('li');
      item.innerHTML = result;
      document.getElementById("output").appendChild(item);
    }
  
    function keydown(event){
      if(event.keyCode == 13){
        enter();
      }
    }

    function listStorage(){
      var result = nil;
      for(var i =0; i < localStorage.length; i++){
        result = cons(intern(localStorage.key(i)), result);
      }
      return result;
    }

    function saveStorage(symbol){
      value = eval(symbol, env);
      localStorage.setItem(symbol.name, value.toString());
      return value;
    }

    function loadStorage(symbol){
      var code = localStorage.getItem(symbol.name);
      eval(read(["(define",symbol.name,code,")"].join(" ")),env);
      return symbol;
    }
    registerKeyword("storage->list",listStorage);
    registerKeyword("storage->save",saveStorage, ['variable']);  
    registerKeyword("storage->load",loadStorage, ['variable']);  

    registerKeyword("storage->clear",function(){localStorage.clear(); return nil;});


   
    clear = clearOutput = function (){
      document.getElementById("output").innerHTML = "";
      return "";
    }
    function enter(){
      var result;
      try{
        result = eval(read(document.getElementById("cmdline").value.toString()), env);
      } catch(e){
        result = e;
      }
      appendResult(result);
    }

    function fromEnv(){
      var cmdline = document.getElementById("cmdline");
      var result = "";
      var variable = cmdline.value.toString();
      var depth = 0;
       
      try{
        var code = ["(define ", variable, eval(read(variable), env).toString(), ")"].join("") ;
        
        for(var i =0 ; i < code.length; i++){
          if(code[i] == "(" ){
            if( code[i - 1] && code[i - 1] != "("){
              result = result + '\n';
              
              for(var j = 0; j < depth; j ++){
                result = result + "  ";
              }
            }
            depth = depth + 1;
          } else if (code[i] == ")"){
            depth = depth - 1;
          }
          result = result + code[i];
        }
        cmdline.value = result; 
      } catch(e){
        appendResult(e);
      }
    }

    function add(token){
      var cmdline = document.getElementById("cmdline");
      var caret = cmdline.selectionStart;


      insertText(token, caret);
    }

    function balance(){
      var cmdline = document.getElementById("cmdline");

      var open = cmdline.value.split("(").length -1;
      var closed = cmdline.value.split(")").length -1;

      var r = "";
      while(open > closed){
       r = r + ")";
       closed = closed +1;
      }
      cmdline.value = cmdline.value + r;
    }
    loadWizardGame();

    (function (){
      document.getElementById("cmdline").style.width = document.getElementById("body").offsetWidth;
    })()
  </script>
      </section>
    </div>

    
  </body>
</html>